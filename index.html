<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smooth Minimal Tetris</title>
<style>
body {
    margin:0;
    font-family:'Segoe UI',sans-serif;
    display:flex;
    justify-content:center;
    align-items:flex-start;
    min-height:100vh;
    background: linear-gradient(135deg,#0d1117,#1c1f26);
    color:#fff;
}
.game-wrapper {
    display:flex;
    gap:20px;
    margin-top:20px;
}
.tetris-container {
    position:relative;
    width:300px;
    height:600px;
    background: rgba(255,255,255,0.03);
    border:2px solid #fff;
    border-radius:10px;
    overflow:hidden;
}
.block {
    position:absolute;
    width:30px;
    height:30px;
    border-radius:6px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    backdrop-filter: blur(2px);
    transition: top 0.1s linear, left 0.1s linear;
}
.sidebar {
    display:flex;
    flex-direction:column;
    gap:20px;
}
.box {
    width:120px;
    height:120px;
    background: rgba(255,255,255,0.05);
    border:2px solid #fff;
    border-radius:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:20px;
    text-align:center;
}
.button {
    padding:10px;
    border-radius:8px;
    border:none;
    cursor:pointer;
    font-weight:bold;
    background:#fff;
    color:#0d1117;
}
.button:hover { background:#e1e1e1; }
</style>
</head>
<body>

<div class="game-wrapper">
    <div class="tetris-container" id="tetris"></div>
    <div class="sidebar">
        <div class="box" id="score">Score: 0</div>
        <div class="box" id="level">Level: 1</div>
        <div class="box" id="hold">Hold</div>
        <div class="box" id="next">Next</div>
        <button class="button" id="restartBtn">Restart</button>
        <button class="button" id="pauseBtn">Pause</button>
    </div>
</div>

<script>
const container = document.getElementById('tetris');
const scoreDisplay = document.getElementById('score');
const levelDisplay = document.getElementById('level');
const nextDisplay = document.getElementById('next');
const holdDisplay = document.getElementById('hold');
const restartBtn = document.getElementById('restartBtn');
const pauseBtn = document.getElementById('pauseBtn');

const width = 10;
const height = 20;
const blockSize = 30;

let gameBoard = [];
let score = 0;
let level = 1;
let speed = 500;
let timerId;
let isPaused = false;

let currentTetromino;
let currentPosition;
let nextTetromino;
let holdTetromino = null;
let canHold = true;

// Tetromino shapes
const tetrominoes = [
    [[0,0],[0,1],[0,2],[1,2]], // L
    [[0,1],[0,2],[1,0],[1,1]], // Z
    [[0,1],[1,0],[1,1],[1,2]], // T
    [[0,0],[0,1],[1,0],[1,1]], // O
    [[0,1],[1,1],[2,1],[3,1]]  // I
];

// ===== INITIALIZE GAME =====
function initGame(){
    container.innerHTML = '';
    gameBoard = Array.from({length:height},()=>Array(width).fill(null));
    score=0; level=1; speed=500; canHold=true;
    updateScore(); updateLevel();
    chooseNextTetromino();
    spawnTetromino();
    clearInterval(timerId);
    timerId = setInterval(gameLoop, speed);
}

// ===== SPAWN TETROMINO =====
function chooseNextTetromino(){
    const r = Math.floor(Math.random()*tetrominoes.length);
    nextTetromino = tetrominoes[r].map(c=>[c[0],c[1]]);
    updateNextDisplay();
}

function spawnTetromino(){
    currentTetromino = nextTetromino.map(c=>[c[0],c[1]]);
    currentPosition = {x:3, y:0};
    chooseNextTetromino();
    canHold = true;
    if(collision(currentTetromino, currentPosition)){
        clearInterval(timerId);
        alert('Game Over! Score: '+score);
    }
    draw();
}

// ===== DRAWING =====
function draw(){
    container.innerHTML='';
    for(let y=0;y<height;y++){
        for(let x=0;x<width;x++){
            if(gameBoard[y][x]) drawBlock(x,y);
        }
    }
    currentTetromino.forEach(([dy,dx])=>{
        const x = currentPosition.x + dx;
        const y = currentPosition.y + dy;
        if(y>=0) drawBlock(x,y);
    });
}

function drawBlock(x,y){
    const block = document.createElement('div');
    block.classList.add('block');
    block.style.left = x*blockSize + 'px';
    block.style.top = y*blockSize + 'px';
    container.appendChild(block);
}

// ===== COLLISION =====
function collision(tet,pos){
    for(let [dy,dx] of tet){
        const x = pos.x + dx;
        const y = pos.y + dy;
        if(x<0 || x>=width || y>=height) return true;
        if(y>=0 && gameBoard[y][x]) return true;
    }
    return false;
}

// ===== MOVE =====
function moveDown(){
    currentPosition.y++;
    if(collision(currentTetromino,currentPosition)){
        currentPosition.y--;
        freeze();
        return;
    }
    draw();
}
function moveLeft(){currentPosition.x--; if(collision(currentTetromino,currentPosition)) currentPosition.x++; draw();}
function moveRight(){currentPosition.x++; if(collision(currentTetromino,currentPosition)) currentPosition.x--; draw();}
function rotate(){const newShape=currentTetromino.map(([y,x])=>[x,-y]); const old=currentTetromino; currentTetromino=newShape; if(collision(currentTetromino,currentPosition)) currentTetromino=old; draw();}

// ===== FREEZE =====
function freeze(){
    currentTetromino.forEach(([dy,dx])=>{
        const x = currentPosition.x+dx;
        const y = currentPosition.y+dy;
        if(y>=0) gameBoard[y][x]=true;
    });
    clearLines();
    spawnTetromino();
}

// ===== CLEAR LINES =====
function clearLines(){
    let lines=0;
    for(let y=height-1;y>=0;y--){
        if(gameBoard[y].every(c=>c)){
            gameBoard.splice(y,1);
            gameBoard.unshift(Array(width).fill(null));
            lines++;
            y++;
        }
    }
    if(lines>0){
        score+=lines*10;
        level=Math.floor(score/100)+1;
        updateScore();
        updateLevel();
        clearInterval(timerId);
        timerId=setInterval(gameLoop, Math.max(100, speed-(level-1)*30));
    }
}

// ===== SCORE/LEVEL/HOLD/NEXT =====
function updateScore(){scoreDisplay.textContent='Score: '+score;}
function updateLevel(){levelDisplay.textContent='Level: '+level;}
function updateNextDisplay(){nextDisplay.textContent='Next';}
function hold(){
    if(!canHold) return;
    if(!holdTetromino){holdTetromino=currentTetromino.map(c=>[c[0],c[1]]); spawnTetromino();}
    else {[currentTetromino,holdTetromino]=[holdTetromino,currentTetromino]; currentPosition={x:3,y:0};}
    canHold=false;
    holdDisplay.textContent='Hold';
}

// ===== GAME LOOP =====
function gameLoop(){if(!isPaused) moveDown();}

// ===== KEYBOARD =====
document.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft') moveLeft();
    else if(e.key==='ArrowRight') moveRight();
    else if(e.key==='ArrowDown') moveDown();
    else if(e.key==='ArrowUp') rotate();
    else if(e.key==='c' || e.key==='C') hold();
    else if(e.key==='p' || e.key==='P') togglePause();
});

// ===== BUTTONS =====
restartBtn.addEventListener('click', initGame);
pauseBtn.addEventListener('click', togglePause);
function togglePause(){isPaused=!isPaused; pauseBtn.textContent=isPaused?'Resume':'Pause';}

// ===== START =====
initGame();
</script>
</body>
</html>
